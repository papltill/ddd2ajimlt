


module ddd2ajimlt;
create OUT : AJI from IN : DDD;

-- Quick way to check if an element has a specific Stereotype applied
helper context DDD!Element def: hasStereotype(stereotype : String) : Boolean =
	self.getAppliedStereotypes() -> exists(e|e.name=stereotype);


--Can be used if the type of a property is a primitive type from UML (String,Integer,Boolean etc.)
helper context DDD!Property def: isPrimitiveType(type : String): Boolean =
	if self.type.oclIsUndefined() then
		false
			else
				if self.type.oclIsTypeOf(DDD!PrimitiveType) and self.type.name = type then
			true
			else
				false
			endif
		
				endif;

-- retreive the value of the Aggregate Root Property of an Element that has the AggregatePart Stereotype from DDD applied
helper context DDD!Element def: getAggregateRoot() : DDD!Element =
	if self.hasStereotype('AggregatePart')
	then
		self.getValue(self.getAppliedStereotype('RootElement::AggregatePart'),'aggregateRoot')
	else
		self
	endif;

helper context DDD!Class def: getAllAssocationsFromProperties() : Sequence(DDD!Assocation) =
	self.attribute -> iterate(iter; col: Sequence(DDD!Association) = Sequence{}| 
	col.append(iter.association)
	);

-- Filters a sequence of classes to only contain Objects with the applied stereotype
helper def: filterSequenceByStereotype(seq : Sequence(DDD!Class), stereotype : String) : Sequence(DDD!Class) =
	seq -> iterate(iter; col: Sequence(DDD!Class) = Sequence{}|
	if iter.hasStereotype(stereotype)
	then
		col.append(iter)
	else
		col
	endif
	);

-- Filters a sequence of classes to only contain Objects with the applied stereotype
helper def: filterSequenceByType(seq : Sequence(DDD!Class), type : String) : Sequence(DDD!Class) =
	seq -> iterate(iter; col: Sequence(DDD!Class) = Sequence{}|
	if iter.oclIsTypeOf(type)
	then
		col.append(iter)
	else
		col
	endif
	);

helper context DDD!Package def: packagedAbstractClasses() : Sequence(DDD!Class) =
	self.getPackagedElementsByType(DDD!Class) -> iterate(iter; col: Sequence(DDD!Class) = Sequence{}|
	if iter.isAbstract
	then
		col.append(iter)
	else
		col
	endif
	);

helper context DDD!Class def: getGenerelization() : DDD!Class =
	if self.generalization.size() = 0
	then
		DDD!Class
	else
		self.generalization.first().general
	endif;

-- Could also try input.IndexOf(string) to 
helper def: stringContainsRegex(input : String, regex : String) : Boolean =
	let result : String = input.split(regex) in result.size() > 1
	;

-- Check if association is empty before checking stereotypes
helper context DDD!Association def: associationOriginHasStereotype(stereotype : String) : Boolean =
	if(self.memberEnd -> notEmpty())
		then
			self.memberEnd.get(1).type.hasStereotype(stereotype)
		else
			false
	endif;	

helper context DDD!Association def: isManyToManyAssociation() : Boolean =
	if self.memberEnd.size() = 2
		then
			if self.memberEnd.first().upper = -1 and self.memberEnd.get(1).upper = -1
			then
				true
			else
				false
			endif
		else
			false
		endif;

helper context DDD!Association def: isManyToOneAssociation() : Boolean =
	if self.memberEnd.size() = 2
		then
			if self.memberEnd.first().upper = 1 and self.memberEnd.get(1).upper = -1
			then
				true
			else
				false
			endif
		else
			false
		endif;

-- Returns all objects that were created from all dependencies suppliers
helper def: getDependenciesToOtherContexts(seq : Sequence(DDD!Class)) : Sequence(DDD!Class) =
	thisModule.filterSequenceByType(seq, DDD!Dependency) ->
	iterate(iter; col: Sequence(DDD!Class) = Sequence{}|
			if not (iter.supplier.get(0).goUpToElementWithStereotype('BoundedContext').name = iter.client.get(0).goUpToElementWithStereotype('BoundedContext').name)
				then
					col.append(iter.supplier)
				else
					col
				endif	
	);

-- TODO: Delete this
helper context DDD!Dependency def: getValidatedEntity() : DDD!Class =
	if self.supplier.get(0).hasStereotype('Entity')
		then
			self.supplier.get(0)
		else
			DDD!Class
	endif;	

--Count Dependencies on a Class Element, to find out if a service/repo is referenced from outside of the own BC
helper context DDD!Class def: countDependenciesOnThis() : Boolean =
	thisModule.filterSequenceByType(self.goUpToElementWithType(DDD!Model).packagedElement,DDD!Package) -> 
	iterate(iter; col: Sequence(DDD!Class) = Sequence{}|
		if(iter.countDependenciesWithSupplier(self).size() > 0)
			then
				col.append(iter)
		else
			col
		endif);
	
helper context DDD!Package def: countDependenciesWithSupplier(object : DDD!Class) : Boolean =
	thisModule.filterSequenceByType(self.packagedElement, DDD!Dependency) ->
	iterate(iter; col: Sequence(DDD!Dependency) = Sequence{}|
		if(iter.supplier.get(0).name = object.name and 
			not (iter.supplier.get(0).goUpToElementWithStereotype('BoundedContext').name = iter.client.get(0).goUpToElementWithStereotype('BoundedContext').name)) --additionaly filter only dependencies with different bounded contexts
			then
				col.append(iter)
		else
			col
		endif);
	
helper context DDD!Model def: collectAbstractionsWithClient(object : DDD!Class) : Boolean =
	thisModule.filterSequenceByType(self.packagedElement, DDD!Abstraction) ->
	iterate(iter; col: Sequence(DDD!Dependency) = Sequence{}|
		if(iter.client.get(0).name = object.name)
			then
				col.append(iter)
		else
			col
		endif);

helper context DDD!Element def: goUpToElementWithStereotype (stereotype : String) : DDD!Element =
	if(not self.namespace.oclIsUndefined())
		then
			if(self.namespace.hasStereotype(stereotype))
				then
					self.namespace
			else
				self.namespace.goUpToElementWithStereotype(stereotype)
			endif
		else
			self
		endif;

helper context DDD!Element def: goUpToElementWithType (type : OclType) : DDD!Element =
		if(not self.namespace.oclIsUndefined())
		then
			if(self.namespace.oclIsTypeOf(type))
				then
					self.namespace
			else
				self.namespace.goUpToElementWithType(type)
			endif
		else
			self
		endif;

-- Goes recursively through all packages and collects the elements with specified type
helper context DDD!Element def: getPackagedElementsByType(type : String) : Sequence(DDD!Class) =
		self.packagedElement ->
			iterate(iter; col: Sequence(DDD!Element) = Sequence{}|
		if(iter.oclIsTypeOf(type))
			then
				col.append(iter)
		else
			if(iter.oclIsTypeOf(DDD!Package))
				then
				col.union(iter.getPackagedElementsByType(type))
			else
				col
			endif
		endif);

-- Goes recursively through all packages and collects the elements with specified type
helper context DDD!Element def: getPackagedElementsByStereoType(stereotype : String) : Sequence(DDD!Class) =
		self.packagedElement ->
			iterate(iter; col: Sequence(DDD!Element) = Sequence{}|
		if(iter.hasStereotype(stereotype))
			then
				col.append(iter)
		else
			if(iter.oclIsTypeOf(DDD!Package))
				then
				col.union(iter.getPackagedElementsByStereoType(stereotype))
			else
				col
			endif
		endif);

-- If no return type is given, take the subject from the owing elements associations, else 
helper context DDD!Operation def: getCorrectSubject() : DDD!Element =
	if(self.type.oclIsUndefined())
		then 
			-- return the end of the first association of the owning object
			self.namespace.getAllAssocationsFromProperties().first().memberEnd.first().type
		else
			if(self.type.hasStereotype('ValueObject') and self.type.goUpToElementWithStereotype('BoundedContext').oclIsTypeOf(DDD!Model)) --SharedModel
				then 
					self.type.goUpToElementWithType(DDD!Model).collectAbstractionsWithClient(self.type).first()
				else
					self.type
					endif
	endif;		
	

rule BoundedContext2MicroServiceAndDataModelWithoutAggregate {
	from
		p : DDD!Package (p.oclIsTypeOf(DDD!Package) and p.hasStereotype('BoundedContext') and thisModule.filterSequenceByStereotype(p.packagedElement, 'AggregateRoot').size() = 0)
	to
		
		fs: AJI!FunctionalServiceT (
			name <- p.name + 'Service',
			domain <- dm,
			providedInterfaces <- p.getPackagedElementsByStereoType('Repository'),
			providedInterfaces <- p.getPackagedElementsByStereoType('Service'),
			serviceDependencies <- thisModule.getDependenciesToOtherContexts(p.packagedElement)
		),
		
		dm:	AJI!DataModelT (
			name <- p.name + 'Model',
			entities <- p.getPackagedElementsByStereoType('Entity'),
			entities <- p.getPackagedElementsByStereoType('ValueObject'),
			entities <- p.getPackagedElementsByType(DDD!Enumeration),
			entities <- p.packagedAbstractClasses()
		)
}

rule BoundedContext2MicroServiceAndDataModelWithAggregate {
	from
		p : DDD!Package (p.oclIsTypeOf(DDD!Package) and p.hasStereotype('BoundedContext') and thisModule.filterSequenceByStereotype(p.packagedElement, 'AggregateRoot').size() > 0)
	to
		
		fs: AJI!FunctionalServiceT (
			name <- p.name + 'Service',
			domain <- dm,
			providedInterfaces <- p.getPackagedElementsByStereoType('Repository'),
			providedInterfaces <- p.getPackagedElementsByStereoType('Service'),
			serviceDependencies <- thisModule.getDependenciesToOtherContexts(p.packagedElement)
		),
		
		aggRoot: AJI!EntityT(
			name <- 'AbstractAggregateRoot'
			),
			
		aggPart: AJI!EntityT(
			name <- 'AbstractAggregatePart'
			),
		
		dm:	AJI!DataModelT (
			name <- p.name + 'Model',
			entities <- p.getPackagedElementsByStereoType('Entity'),
			entities <- p.getPackagedElementsByStereoType('ValueObject'),
			entities <- p.getPackagedElementsByType(DDD!Enumeration),
			entities <- p.packagedAbstractClasses(),
			entities <- aggRoot,
			entities <- aggPart
		)
}

rule Model2System {
	
	from
		up : DDD!Model
	to		
		t: AJI!SystemT (
			name <- up.name,
			services <- up.nestedPackage
		)
	
	do{
		--thisModule.println('Blablabla');
		
	}
}

rule AbstractClass2Entity{
	from
		old : DDD!Class (old.isAbstract)
		
	to
		new : AJI!EntityT(
				name <- old.name,
				attributes <- old.attribute,
				relations <- old.getAllAssocationsFromProperties()
			)
}

rule Enum2Entity{
	from
		old : DDD!Enumeration
		
	to
		new : AJI!EntityT(
				name <- old.name,
				attributes <- old.ownedLiteral
			)
}

rule Entity2Entity_AggregateRoot{
	from
		old : DDD!Class (old.hasStereotype('Entity') and old.hasStereotype('AggregateRoot'))
		
	to
		new : AJI!EntityT(
				name <- old.name,
				attributes <- old.attribute,
				relations <- old.getAllAssocationsFromProperties(),
				parent <- thisModule.resolveTemp(old.goUpToElementWithStereotype('BoundedContext'), 'aggRoot'),
				parent <- old.getGenerelization()
			)
}


rule Entity2Entity_NoAggregate{
	from
		old : DDD!Class (old.hasStereotype('Entity') and not old.hasStereotype('AggregateRoot') and not old.hasStereotype('AggregatePart'))
		
	to
		new : AJI!EntityT(
				name <- old.name,
				attributes <- old.attribute,
				relations <- old.getAllAssocationsFromProperties(),
				parent <- old.getGenerelization()
			)
}

rule Entity2Entity_AggregatePart{
	from
		old : DDD!Class (old.hasStereotype('Entity') and old.hasStereotype('AggregatePart'))
		
	to
		new : AJI!EntityT(
				name <- old.name,
				relations <- rel,
				relations <- old.getAllAssocationsFromProperties(),
				attributes <- old.attribute,
				parent <- thisModule.resolveTemp(old.goUpToElementWithStereotype('BoundedContext'), 'aggPart'),
				parent <- old.getGenerelization()
			),
			
			rel : AJI!RelationT(
				name <- 'AggregateRoot',
				target <- old.getAggregateRoot()
			)
}

rule ValueObject2Entity{
	from
		old : DDD!Class (old.hasStereotype('ValueObject') and not old.goUpToElementWithStereotype('BoundedContext').oclIsTypeOf(DDD!Model))
		
	to
		new : AJI!EntityT(
				name <- old.name,
				attributes <- old.attribute
			)
}

rule AbstractionToEntity{
	from 
		old : DDD!Abstraction
	to
		new : AJI!EntityT(
				name <- old.client.get(0).name,
				attributes <- old.client.get(0).attribute,
				--For this to work I had to make dataModel changeable (ask Jonas)
				domainModel <- thisModule.resolveTemp(old.supplier.get(0).goUpToElementWithStereotype('BoundedContext'), 'dm'),
				parent <- old.supplier.get(0)
			)
}

rule PropertyToAttribute_Integer{
	from
		old : DDD!Property (old.isPrimitiveType('Integer')) 
	to	
			new : AJI!IntegerT(
				name <- old.name
			)
}

rule PropertyToAttribute_String{
	from
		old : DDD!Property (old.isPrimitiveType('String')) 
	to	
			new : AJI!StringT(
				name <- old.name
			)
}

rule PropertyToAttribute_Float{
	from
		old : DDD!Property (old.isPrimitiveType('Float')) 
	to	
			new : AJI!FloatT(
				name <- old.name
			)
}

rule PropertyToAttribute_Boolean{
	from
		old : DDD!Property (old.isPrimitiveType('Boolean')) 
	to	
			new : AJI!BooleanT(
				name <- old.name
			)
}

rule PropertyToAttribute_Undefined{
	from
		old : DDD!Property (old.type.oclIsUndefined()  and not(old.name = 'AggregateRoot'))
		
	to	
			new : AJI!StringT(
				name <- old.name
			)
}

rule EnumerationLiterateToAttribute{
	from
		old : DDD!EnumerationLiteral		
	to	
			new : AJI!StringT(
				name <- old.name
			)
}

rule PropertyToAttribute_Association{
	from
		old : DDD!Property (not old.association.oclIsUndefined() and (old.namespace.hasStereotype('Entity') or old.namespace.hasStereotype('ValueObject'))) --and not old.isPropertyOfAssociation())
		
	to	
			-- TODO: when AJI allows entities to have other entities as attributes, use these instead of String
			new : AJI!StringT(
				name <- old.name + ':' + old.name
			)
}

rule RepositoryOrServiceWithOutsideDependenciesToServiceInterface{
	from
		old : DDD!Class ((old.hasStereotype('Repository') or old.hasStereotype('Service')) and old.countDependenciesOnThis().size() > 0)
	to
		new : AJI!ServiceInterfaceT(
				name <- old.name + 'Interface',
				abilities <- old.ownedOperation
			)
}

--rule RepositoryOrServiceWithoutOutsideDependenciesToLog{
--	from
--		old : DDD!Class ((old.hasStereotype('Repository') or old.hasStereotype('Service')) and old.countDependenciesOnThis().size() = 0)
--	to
	
--	do{
--		('"Repository" or "Service" object with name "'+old.name+'" was not converted because there is no corresponding concept in AJIL"').println();
--	}
		
--}

--Checking the type with the first characters, because a regex search can be ambigoous with createReader or something
rule OperationToCreateAbility{
	from
		old: DDD!Operation (old.namespace.hasStereotype('Service') and
			old.name.substring(1,6) = 'create' and old.namespace.countDependenciesOnThis().size() > 0)
	to
		new : AJI!CreateT( 
				name <- old.name,
				--No way to distinguish between multiple associations on a repo or service
				subject <- old.namespace.getAllAssocationsFromProperties().first().memberEnd.first().type
			)
}

rule OperationToReadAbility{
	from
		old: DDD!Operation (old.namespace.hasStereotype('Repository') or (old.namespace.hasStereotype('Service') and
			(old.name.substring(1,4) = 'find' or old.name.substring(1,4) = 'read' or old.name.substring(1,3) = 'get'))
			and old.namespace.countDependenciesOnThis().size() > 0)
	to
		new : AJI!ReadT( 
				name <- old.name,
				--No way to distinguish between multiple associations on a repo or service
				subject <- old.getCorrectSubject()
			)
}

rule OperationToUpdateAbility{
	from
		old: DDD!Operation (old.namespace.hasStereotype('Service') and
			old.name.substring(1,6) = 'update' and old.namespace.countDependenciesOnThis().size() > 0)
	to
		new : AJI!UpdateT( 
				name <- old.name,
				--No way to distinguish between multiple associations on a repo or service
				subject <- old.namespace.getAllAssocationsFromProperties().first().memberEnd.first().type
			)
}

rule OperationToDeleteAbility{
	from
		old: DDD!Operation (old.namespace.hasStereotype('Service') and
			(old.name.substring(1,6) = 'delete' or old.name.substring(1,6) = 'remove')
			and old.namespace.countDependenciesOnThis().size() > 0)
	to
		new : AJI!DeleteT( 
				name <- old.name,
				--No way to distinguish between multiple associations on a repo or service
				subject <- old.namespace.getAllAssocationsFromProperties().first().memberEnd.first().type
			)
}

--TODO: Right now not custom, but read, because custom does not have subject
rule OperationToCustomAbility{
	from
		old: DDD!Operation (old.namespace.hasStereotype('Service') and not
			(old.name.substring(1,6) = 'create' or
				old.name.substring(1,4) = 'find' or old.name.substring(1,4) = 'read' or old.name.substring(1,3) = 'get' or
				old.name.substring(1,6) = 'update'or
				old.name.substring(1,6) = 'delete' or old.name.substring(1,6) = 'remove')	
			and old.namespace.countDependenciesOnThis().size() > 0
		)
	to
		new : AJI!ReadT( 
				name <- old.name + '(Custom)',
				--No way to distinguish between multiple associations on a repo or service
				subject <- old.namespace.getAllAssocationsFromProperties().first().memberEnd.first().type
			)
}


rule EntityAssociations{
	from
		old : DDD!Association (old.associationOriginHasStereotype('Entity') and not old.isManyToManyAssociation() 
			and not old.isManyToOneAssociation())
		
	to	
			new : AJI!RelationT(
				target <- old.memberEnd.first().type,
				source <- old.memberEnd.get(1).type,
				multiplicity <-  if (old.memberEnd.first().upper.debug() = -1) then 'MANY' else 'ONE' endif
			)
}

rule splitManyToManyEntityAssociations{
	from
		old : DDD!Association (old.associationOriginHasStereotype('Entity') and old.isManyToManyAssociation())
		
	to	
			new : AJI!RelationT(
				target <- old.memberEnd.first().type,
				source <- old.memberEnd.get(1).type,
				multiplicity <- 'MANY'
			),
			
			new2 : AJI!RelationT(
				target <- old.memberEnd.get(1).type,
				source <- old.memberEnd.first().type,
				multiplicity <- 'MANY'
			)
}

rule SpecToLog{
	from
		old : DDD!Class (old.hasStereotype('Spec'))
		
	to	

	do{
		('"Spec" object with name "'+old.client.get(0).name+ '" was not converted, because there is no corresponding concept in AJIL').println();
	}	
}

rule log(log : String){
	to 
			si: AJI!System(
			name <- log
			)
	do {
		
	}
}


