


module ddd2ajimlt;
create OUT : AJI from IN : DDD;

-- Quick way to check if an element has a specific Stereotype applied
helper context DDD!Element def: hasStereotype(stereotype : String) : Boolean =
	self.getAppliedStereotypes() -> exists(e|e.name=stereotype);


--Can be used if the type of a property is a primitive type from UML (String,Integer,Boolean etc.)
helper context DDD!Property def: isPrimitiveType(type : String): Boolean =
	if self.type.oclIsUndefined() then
		false
			else
				if self.type.oclIsTypeOf(DDD!PrimitiveType) and self.type.name = type then
			true
			else
				false
			endif
		
				endif;

-- retreive the value of the Aggregate Root Property of an Element that has the AggregatePart Stereotype from DDD applied
helper context DDD!Element def: getAggregateRoot() : DDD!Element =
	if self.hasStereotype('AggregatePart')
	then
		self.getValue(self.getAppliedStereotype('RootElement::AggregatePart'),'aggregateRoot')
	else
		self
	endif;

helper context DDD!Class def: getAllAssocationsFromProperties() : Sequence(DDD!Assocation) =
	self.attribute -> iterate(iter; col: Sequence(DDD!Association) = Sequence{}| 
	col.append(iter.association)
	);

-- Filters a sequence of classes to only contain Objects with the applied stereotype
helper def: filterSequenceByStereotype(seq : Sequence(DDD!Class), stereotype : String) : Sequence(DDD!Class) =
	seq -> iterate(iter; col: Sequence(DDD!Class) = Sequence{}|
	if iter.hasStereotype(stereotype)
	then
		col.append(iter)
	else
		col
	endif
	);

-- Filters a sequence of classes to only contain Objects with the applied stereotype
helper def: filterSequenceByType(seq : Sequence(DDD!Class), type : String) : Sequence(DDD!Class) =
	seq -> iterate(iter; col: Sequence(DDD!Class) = Sequence{}|
	if iter.oclIsTypeOf(type)
	then
		col.append(iter)
	else
		col
	endif
	);

helper context DDD!Package def: packagedAbstractClasses() : Sequence(DDD!Class) =
	self.getPackagedElementsByType(DDD!Class) -> iterate(iter; col: Sequence(DDD!Class) = Sequence{}|
	if iter.isAbstract
	then
		col.append(iter)
	else
		col
	endif
	);

helper context DDD!Class def: getGenerelization() : DDD!Class =
	if self.generalization.size() = 0
	then
		DDD!Class
	else
		self.generalization.first().general
	endif;

-- Could also try input.IndexOf(string) to 
helper def: stringContainsRegex(input : String, regex : String) : Boolean =
	let result : String = input.split(regex) in result.size() > 1
	;

-- Check if association is empty before checking stereotypes
helper context DDD!Association def: associationOriginHasStereotype(stereotype : String) : Boolean =
	if(self.memberEnd -> notEmpty())
		then
			self.memberEnd.get(1).type.hasStereotype(stereotype)
		else
			false
	endif;	

helper context DDD!Association def: isManyToManyAssociation() : Boolean =
	if self.memberEnd.size() = 2
		then
			if self.memberEnd.first().upper = -1 and self.memberEnd.get(1).upper = -1
			then
				true
			else
				false
			endif
		else
			false
		endif;

helper context DDD!Association def: isManyToOneAssociation() : Boolean =
	if self.memberEnd.size() = 2
		then
			if self.memberEnd.first().upper = 1 and self.memberEnd.get(1).upper = -1
			then
				true
			else
				false
			endif
		else
			false
		endif;

-- Returns all objects that were created from all dependencies suppliers
helper def: getDependenciesToOtherContexts(seq : Sequence(DDD!Class)) : Sequence(DDD!Class) =
	thisModule.filterSequenceByType(seq, DDD!Dependency) ->
	iterate(iter; col: Sequence(DDD!Class) = Sequence{}|
			if not (iter.supplier.get(0).goUpToElementWithStereotype('BoundedContext').name = iter.client.get(0).goUpToElementWithStereotype('BoundedContext').name)
				then
					col.append(iter.supplier)
				else
					col
				endif	
	);

-- TODO: Delete this
helper context DDD!Dependency def: getValidatedEntity() : DDD!Class =
	if self.supplier.get(0).hasStereotype('Entity')
		then
			self.supplier.get(0)
		else
			DDD!Class
	endif;	

--Count Dependencies on a Class Element, to find out if a service/repo is referenced from outside of the own BC
helper context DDD!Class def: countDependenciesOnThis() : Boolean =
	thisModule.filterSequenceByType(self.goUpToElementWithType(DDD!Model).packagedElement,DDD!Package) -> 
	iterate(iter; col: Sequence(DDD!Class) = Sequence{}|
		if(iter.countDependenciesWithSupplier(self).size() > 0)
			then
				col.append(iter)
		else
			col
		endif);
	
helper context DDD!Package def: countDependenciesWithSupplier(object : DDD!Class) : Boolean =
	thisModule.filterSequenceByType(self.packagedElement, DDD!Dependency) ->
	iterate(iter; col: Sequence(DDD!Dependency) = Sequence{}|
		if(iter.supplier.get(0).name = object.name and 
			not (iter.supplier.get(0).goUpToElementWithStereotype('BoundedContext').name = iter.client.get(0).goUpToElementWithStereotype('BoundedContext').name)) --additionaly filter only dependencies with different bounded contexts
			then
				col.append(iter)
		else
			col
		endif);
	
helper context DDD!Model def: collectAbstractionsWithClient(object : DDD!Class) : Boolean =
	thisModule.filterSequenceByType(self.packagedElement, DDD!Abstraction) ->
	iterate(iter; col: Sequence(DDD!Dependency) = Sequence{}|
		if(iter.client.get(0).name = object.name)
			then
				col.append(iter)
		else
			col
		endif);

helper context DDD!Package def: collectAbstractionsWithClientBC(object : DDD!Class) : Boolean =
	thisModule.filterSequenceByType(self.packagedElement, DDD!Abstraction) ->
	iterate(iter; col: Sequence(DDD!Dependency) = Sequence{}|
		if(iter.client.get(0).name = object.name)
			then
				col.append(iter)
		else
			col
		endif);

helper context DDD!Element def: collectAssociationsWithMemberEnd(object : DDD!Class) : Boolean =
	self.getPackagedElementsByType(DDD!Association) ->
	iterate(iter; col: Sequence(DDD!Association) = Sequence{}|
		if(iter.memberEnd.get(1).type.name = object.name)
			then
				col.append(iter)
		else
			col
		endif);

helper context DDD!Element def: goUpToElementWithStereotype (stereotype : String) : DDD!Element =
	if(self.hasStereotype(stereotype))
		then
			self
		else
			if(not self.namespace.oclIsUndefined())
				then
					self.namespace.goUpToElementWithStereotype(stereotype)
				else
					OclUndefined
				endif
		endif;

helper context DDD!Element def: goUpToElementWithType (type : OclType) : DDD!Element =
	if(self.oclIsTypeOf(type))
		then
			self
		else
			if(not self.namespace.oclIsUndefined())
				then
					self.namespace.goUpToElementWithType(type)
				else
					OclUndefined
				endif
		endif;

-- Goes recursively through all packages and collects the elements with specified type
helper context DDD!Element def: getPackagedElementsByType(type : String) : Sequence(DDD!Class) =
		self.packagedElement ->
			iterate(iter; col: Sequence(DDD!Element) = Sequence{}|
		if(iter.oclIsTypeOf(type))
			then
				col.append(iter)
		else
			if(iter.oclIsTypeOf(DDD!Package))
				then
				col.union(iter.getPackagedElementsByType(type))
			else
				col
			endif
		endif);

-- Goes recursively through all packages and collects the elements with specified type
helper context DDD!Element def: getPackagedElementsByStereoType(stereotype : String) : Sequence(DDD!Class) =
		self.packagedElement ->
			iterate(iter; col: Sequence(DDD!Element) = Sequence{}|
		if(iter.hasStereotype(stereotype))
			then
				col.append(iter)
		else
			if(iter.oclIsTypeOf(DDD!Package))
				then
				col.union(iter.getPackagedElementsByStereoType(stereotype))
			else
				col
			endif
		endif);

-- If no return type is given, take the subject from the owing elements associations, else 
helper context DDD!Operation def: getCorrectSubject() : DDD!Element =
	if(self.type.oclIsUndefined())
		then 
			-- return the end of the first association of the owning object
			if not self.namespace.getAllAssocationsFromProperties().first().oclIsUndefined()
				then
					self.namespace.getAllAssocationsFromProperties().first().memberEnd.first().type
				else
					thisModule.resolveTemp(self.namespace.goUpToElementWithType(DDD!Model).collectAssociationsWithMemberEnd(self.namespace).first().memberEnd.get(0).type,'new')
			endif
		else
			if(self.type.hasStereotype('ValueObject') and self.type.goUpToElementWithStereotype('BoundedContext').oclIsTypeOf(DDD!Model)) --SharedModel
				then 
					self.type.goUpToElementWithType(DDD!Model).collectAbstractionsWithClient(self.type).first()
				else
					self.type
					endif
	endif;		

helper context DDD!Class def: suitableForInterface() : Boolean =
	if((self.hasStereotype('Repository') or self.hasStereotype('Service')))
		then
			if(self.countDependenciesOnThis().size() > 0)
				then
					true
				else
					-- =0 is to just have a false expression
					('Repository" or "Service" object with name "'+self.name+'" was not converted because there is no corresponding concept in AJIL').debug() = 0
				endif
		else 
			false
		endif;

helper def: getAbstractFromElement(element : DDD!Element) : DDD!Element =
	if(not element.goUpToElementWithStereotype('BoundedContext').oclIsUndefined())
		then
			element.goUpToElementWithStereotype('BoundedContext').collectAbstractionsWithClientBC(element).first()
		else
			OclUndefined
		endif;

helper def: getAbstractFromSharedModel(element : DDD!Element) : DDD!Element =
	if(element.goUpToElementWithStereotype('BoundedContext').oclIsUndefined())
		then
			element.goUpToElementWithType(DDD!Model).collectAbstractionsWithClient(element).first()
		else
			OclUndefined
		endif;

-- Helper to find out if both ends are transformed to other stuff, currently not working
helper context DDD!Association def: bothEndsTransformed() : Boolean =
	if(thisModule.resolveTemp(self.memberEnd.first().debug(),'new').debug().oclIsUndefined() or thisModule.resolveTemp(self.memberEnd.get(1).debug(), 'new').debug().oclIsUndefined())
		then
			false
		else
			true
		endif;

rule BoundedContext2MicroServiceAndDataModelWithoutAggregate {
	from
		p : DDD!Package (p.oclIsTypeOf(DDD!Package) and p.hasStereotype('BoundedContext') and thisModule.filterSequenceByStereotype(p.packagedElement, 'AggregateRoot').size() = 0)
	to
		
		fs: AJI!FunctionalServiceT (
			name <- p.name + 'Service',
			domain <- dm,
			providedInterfaces <- p.getPackagedElementsByStereoType('Repository'),
			providedInterfaces <- p.getPackagedElementsByStereoType('Service'),
			serviceDependencies <- thisModule.getDependenciesToOtherContexts(p.packagedElement)
		),
		
		dm:	AJI!DataModelT (
			name <- p.name + 'Model',
			entities <- p.getPackagedElementsByStereoType('Entity'),
			entities <- p.getPackagedElementsByStereoType('ValueObject'),
			entities <- p.getPackagedElementsByType(DDD!Enumeration),
			entities <- p.packagedAbstractClasses()
		)
}

rule BoundedContext2MicroServiceAndDataModelWithAggregate {
	from
		p : DDD!Package (p.oclIsTypeOf(DDD!Package) and p.hasStereotype('BoundedContext') and thisModule.filterSequenceByStereotype(p.packagedElement, 'AggregateRoot').size() > 0)
	to
		
		fs: AJI!FunctionalServiceT (
			name <- p.name + 'Service',
			domain <- dm,
			providedInterfaces <- p.getPackagedElementsByStereoType('Repository'),
			providedInterfaces <- p.getPackagedElementsByStereoType('Service'),
			serviceDependencies <- thisModule.getDependenciesToOtherContexts(p.packagedElement)
		),
		
		aggRoot: AJI!EntityT(
			name <- 'AbstractAggregateRoot'
			),
			
		aggPart: AJI!EntityT(
			name <- 'AbstractAggregatePart'
			),
		
		dm:	AJI!DataModelT (
			name <- p.name + 'Model',
			entities <- p.getPackagedElementsByStereoType('Entity'),
			entities <- p.getPackagedElementsByStereoType('ValueObject'),
			entities <- p.getPackagedElementsByType(DDD!Enumeration),
			entities <- p.packagedAbstractClasses(),
			entities <- aggRoot,
			entities <- aggPart
		)
}

rule Module2Log{
	from
		old : DDD!Package (old.hasStereotype('Module'))
		
	to	

	do{
		('"Module" object with name "'+old.name+ '" was not converted, because there is no corresponding concept in AJIL').println();
	}	
}

rule Model2System {
	
	from
		up : DDD!Model
	to		
		t: AJI!SystemT (
			name <- up.name,
			services <- up.nestedPackage
		)
	
	do{
		--thisModule.println('Blablabla');
		
	}
}

-- I dont think I need this
--rule AbstractClass2Entity{
--	from
--		old : DDD!Class (old.isAbstract)
		
--	to
--		new : AJI!EntityT(
--				name <- old.name + 'hello',
--				attributes <- old.attribute,
--				relations <- old.getAllAssocationsFromProperties()
--			)
--}

rule Enum2Entity{
	from
		old : DDD!Enumeration
		
	to
		new : AJI!EntityT(
				name <- old.name,
				attributes <- old.ownedLiteral
			)
}

rule Entity2Entity_AggregateRoot{
	from
		old : DDD!Class (old.hasStereotype('Entity') and old.hasStereotype('AggregateRoot'))
		
	to
		new : AJI!EntityT(
				name <- old.name,
				attributes <- old.attribute,
				relations <- old.getAllAssocationsFromProperties(),
				parent <- thisModule.resolveTemp(old.goUpToElementWithStereotype('BoundedContext'), 'aggRoot'),
				parent <- old.getGenerelization()
			)
}


rule Entity2Entity_NoAggregate{
	from
		old : DDD!Class ((old.hasStereotype('Entity') or old.isAbstract = true) and not (old.hasStereotype('AggregateRoot') or old.hasStereotype('AggregatePart')) 
			and thisModule.getAbstractFromElement(old).oclIsUndefined())  --This here because entities with abstractions are created in a seperate rule		
		
	to
		new : AJI!EntityT(
				name <- old.name,
				attributes <- old.attribute,
				relations <- old.getAllAssocationsFromProperties(),
				parent <- old.getGenerelization()
			)
}

rule Entity2Entity_AggregatePart{
	from
		old : DDD!Class (old.hasStereotype('Entity') and old.hasStereotype('AggregatePart'))
		
	to
		new : AJI!EntityT(
				name <- old.name,
				relations <- rel,
				relations <- old.getAllAssocationsFromProperties(),
				attributes <- old.attribute,
				parent <- thisModule.resolveTemp(old.goUpToElementWithStereotype('BoundedContext'), 'aggPart'),
				parent <- old.getGenerelization()
			),
			
			rel : AJI!RelationT(
				name <- 'AggregateRoot',
				target <- old.getAggregateRoot()
			)
}

rule ValueObject2Entity{
	from
		old : DDD!Class (old.hasStereotype('ValueObject') and not old.goUpToElementWithStereotype('BoundedContext').oclIsUndefined())
		
	to
		new : AJI!EntityT(
				name <- old.name,
				attributes <- old.attribute
			)
}

-- TODO: Überprüfen, ob es sich um Abstractions von außerhalb des BCs handelt -> SharedModel
rule AbstractionToEntity{
	from 
		old : DDD!Abstraction
	to
		new : AJI!EntityT(
				name <- old.client.get(0).name,
				attributes <- old.client.get(0).attribute,
				--For this to work I had to make dataModel changeable (ask Jonas)
				domainModel <- thisModule.resolveTemp(old.supplier.get(0).goUpToElementWithStereotype('BoundedContext'), 'dm'),
				parent <- old.supplier.get(0)
			)
}

rule PropertyToAttribute_Integer{
	from
		old : DDD!Property (old.isPrimitiveType('Integer')) 
	to	
			new : AJI!IntegerT(
				name <- old.name
			)
}

rule PropertyToAttribute_String{
	from
		old : DDD!Property (old.isPrimitiveType('String')) 
	to	
			new : AJI!StringT(
				name <- old.name
			)
}

rule PropertyToAttribute_Float{
	from
		old : DDD!Property (old.isPrimitiveType('Float')) 
	to	
			new : AJI!FloatT(
				name <- old.name
			)
}

rule PropertyToAttribute_Boolean{
	from
		old : DDD!Property (old.isPrimitiveType('Boolean')) 
	to	
			new : AJI!BooleanT(
				name <- old.name
			)
}

rule PropertyToAttribute_Undefined{
	from
		old : DDD!Property (old.type.oclIsUndefined()  and not(old.name = 'AggregateRoot'))
		
	to	
			new : AJI!StringT(
				name <- old.name
			)
}

rule EnumerationLiterateToAttribute{
	from
		old : DDD!EnumerationLiteral		
	to	
			new : AJI!StringT(
				name <- old.name
			)
}

rule PropertyToAttribute_Association{
	from
		old : DDD!Property (not old.association.oclIsUndefined() and (old.namespace.hasStereotype('Entity') or old.namespace.hasStereotype('ValueObject'))) --and not old.isPropertyOfAssociation())
		
	to	
			-- TODO: when AJI allows entities to have other entities as attributes, use these instead of String
			new : AJI!EntityT(
				name <- old.name
			)
}

rule RepositoryOrServiceToServiceInterface{
	from
		old : DDD!Class (old.suitableForInterface())
	to
		new : AJI!ServiceInterfaceT(
				name <- old.name + 'Interface',
				abilities <- old.ownedOperation
			)
}

--Checking the type with the first characters, because a regex search can be ambigoous with createReader or something
rule OperationToCreateAbility{
	from
		old: DDD!Operation ((old.namespace.hasStereotype('Repository') or old.namespace.hasStereotype('Service')) and
			old.name.substring(1,6) = 'create' and old.namespace.countDependenciesOnThis().size() > 0)
	to
		new : AJI!CreateT( 
				name <- old.name,
				--No way to distinguish between multiple associations on a repo or service
				subject <- old.getCorrectSubject()
			)
}

rule OperationToReadAbility{
	from
		old: DDD!Operation ((old.namespace.hasStereotype('Repository') or old.namespace.hasStereotype('Service')) and
			(old.name.substring(1,4) = 'find' or old.name.substring(1,4) = 'read' or old.name.substring(1,3) = 'get')
			and old.namespace.countDependenciesOnThis().size() > 0)
	to
		new : AJI!ReadT( 
				name <- old.name,
				--No way to distinguish between multiple associations on a repo or service
				subject <- old.getCorrectSubject()
			)
}

rule OperationToUpdateAbility{
	from
		old: DDD!Operation ((old.namespace.hasStereotype('Repository') or old.namespace.hasStereotype('Service')) and
			old.name.substring(1,6) = 'update' and old.namespace.countDependenciesOnThis().size() > 0)
	to
		new : AJI!UpdateT( 
				name <- old.name,
				--No way to distinguish between multiple associations on a repo or service
				subject <- old.getCorrectSubject()
			)
}

rule OperationToDeleteAbility{
	from
		old: DDD!Operation ((old.namespace.hasStereotype('Repository') or old.namespace.hasStereotype('Service')) and
			(old.name.substring(1,6) = 'delete' or old.name.substring(1,6) = 'remove')
			and old.namespace.countDependenciesOnThis().size() > 0)
	to
		new : AJI!DeleteT( 
				name <- old.name,
				--No way to distinguish between multiple associations on a repo or service
				subject <- old.getCorrectSubject()
			)
}

--TODO: Right now not custom, but read, because custom does not have subject
rule OperationToCustomAbility{
	from
		old: DDD!Operation (old.namespace.hasStereotype('Service') and not
			(old.name.substring(1,6) = 'create' or
				old.name.substring(1,4) = 'find' or old.name.substring(1,4) = 'read' or old.name.substring(1,3) = 'get' or
				old.name.substring(1,6) = 'update'or
				old.name.substring(1,6) = 'delete' or old.name.substring(1,6) = 'remove')	
			and old.namespace.countDependenciesOnThis().size() > 0
		)
	to
		new : AJI!CustomT( 
				name <- old.name,
				--No way to distinguish between multiple associations on a repo or service
				subject <- old.getCorrectSubject()
			)
}


rule EntityAssociations{
	from
		old : DDD!Association (old.associationOriginHasStereotype('Entity') and not old.isManyToManyAssociation() 
			and not old.isManyToOneAssociation())
		
	to	
			new : AJI!RelationT(
				target <- old.memberEnd.first().type,
				source <- old.memberEnd.get(1).type,
				multiplicity <-  if (old.memberEnd.first().upper = -1) then 'MANY' else 'ONE' endif,
				name <- old.memberEnd.get(1).name + '->' + old.memberEnd.first().name
			)
}

rule splitManyToManyEntityAssociations{
	from
		old : DDD!Association (old.associationOriginHasStereotype('Entity') and old.isManyToManyAssociation())
		-- Checken ob Assoziationen zwischen Bounded Contexts sind
	using{
			firstElement : DDD!Element = thisModule.getAbstractFromSharedModel(old.memberEnd.first().type);
			secondElement: DDD!Element = thisModule.getAbstractFromSharedModel(old.memberEnd.get(1).type);
	}
	to	
			new : AJI!RelationT(
				target <- old.memberEnd.first().type,
				-- This is added additionaly to each setting, because some entities are created by Converting there Abstractions rather than the Elements themselves
				target <- firstElement,
				source <- old.memberEnd.get(1).type,
				source <- secondElement,
				multiplicity <- 'MANY',
				name <- '1: ' + old.memberEnd.get(1).name + '->' + old.memberEnd.first().name
			),
			
			new2 : AJI!RelationT(
				target <- old.memberEnd.get(1).type,
				target <- secondElement,
				source <- old.memberEnd.first().type,
				source <- firstElement,
				multiplicity <- 'MANY',
				name <- '2: ' + old.memberEnd.first().name + '->' + old.memberEnd.get(1).name
			)
}

rule SpecToLog{
	from
		old : DDD!Class (old.hasStereotype('Spec'))
		
	to	

	do{
		('"Spec" object with name "'+old.name+ '" was not converted, because there is no corresponding concept in AJIL').println();
	}	
}

rule log(log : String){
	to 
			si: AJI!System(
			name <- log
			)
	do {
		
	}
}


