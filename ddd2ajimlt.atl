-- @atlcompiler emftvm

module ddd2ajimlt;
create OUT : AJI from IN : DDD;

-- Quick way to check if an element has a specific Stereotype applied
helper context DDD!Element def: hasStereotype(stereotype : String) : Boolean =
	self.getAppliedStereotypes() -> exists(e|e.name=stereotype);


--Can be used if the type of a property is a primitive type from UML (String,Integer,Boolean etc.)
helper context DDD!Property def: isPrimitiveType(type : String): Boolean =
	if self.type.oclIsUndefined() then
		false
			else
				if self.type.oclIsTypeOf(DDD!PrimitiveType) and self.type.name = type then
			true
			else
				false
			endif
		
				endif;

-- retreive the value of the Aggregate Root Property of an Element that has the AggregatePart Stereotype from DDD applied
helper context DDD!Element def: getAggregateRoot() : DDD!Element =
	if self.hasStereotype('AggregatePart')
	then
		self.getValue(self.getAppliedStereotype('RootElement::AggregatePart'),'aggregateRoot')
	else
		self
	endif;

helper context DDD!Class def: getAllAssocationsFromProperties() : Sequence(DDD!Assocation) =
	self.attribute -> iterate(iter; col: Sequence(DDD!Association) = Sequence{}| 
	col.append(iter.association)
	);

helper context DDD!Class def: getGeneralization() : DDD!Class =
	if self.generalization.size() = 0
		then
			OclUndefined
		else
			self.generalization.first().general
	endif;

helper context DDD!Class def: generalizationHasStereotype(stereotype : String): Boolean =
	if(self.getGeneralization().oclIsUndefined())
		then
			false
		else
			if(self.getGeneralization().hasStereotype(stereotype))
				then
					true
				else
					false
				endif
		endif;

helper context DDD!Class def: generalizationBoundedContext() : DDD!Package =
	if(self.generalizationHasStereotype('Entity'))
		then
			self.getGeneralization().goUpToElementWithStereotype('BoundedContext')
		else
			OclUndefined
	endif;
			
			
-- Could also try input.IndexOf(string) to 
helper def: stringContainsRegex(input : String, regex : String) : Boolean =
	let result : String = input.split(regex) in result.size() > 1
	;

-- Check if association is empty before checking stereotypes
helper context DDD!Association def: associationOriginHasStereotype(stereotype : String) : Boolean =
	if(self.memberEnd -> notEmpty())
		then
			self.memberEnd.get(1).type.hasStereotype(stereotype)
		else
			false
	endif;	

helper context DDD!Association def: isManyToManyAssociation() : Boolean =
	if self.memberEnd.size() = 2
		then
			if self.memberEnd.first().upper = -1 and self.memberEnd.get(1).upper = -1
			then
				true
			else
				false
			endif
		else
			false
		endif;

helper context DDD!Association def: isManyToOneAssociation() : Boolean =
	if self.memberEnd.size() = 2
		then
			if self.memberEnd.first().upper = 1 and self.memberEnd.get(1).upper = -1
			then
				true
			else
				false
			endif
		else
			false
		endif;

-- Returns all objects that were created from all dependencies suppliers
helper context DDD!Package def: getDependenciesToOtherContexts(seq : Sequence(DDD!Class)) : Sequence(DDD!Class) =
	self.getPackagedElementsByType(DDD!Dependency) ->
	iterate(iter; col: Sequence(DDD!Class) = Sequence{}|
			if not (iter.supplier.get(0).goUpToElementWithStereotype('BoundedContext').name = iter.client.get(0).goUpToElementWithStereotype('BoundedContext').name)
				then
					col.append(iter.supplier)
				else
					col
				endif	
	);

--Count Dependencies on a Class Element, to find out if a service/repo is referenced from outside of the own BC
helper context DDD!Class def: countDependenciesOnThis() : Boolean =
	self.goUpToElementWithType(DDD!Model).getPackagedElementsByType(DDD!Dependency) -> 
	iterate(iter; col: Sequence(DDD!Class) = Sequence{}|
		if(iter.supplier.get(0).name = self.name)
			then
				if(thisModule.sameBoundedContextNames(iter.supplier.get(0), iter.client.get(0)))
					then
						col.append(iter)
					else
						col
					endif
			else
				col
			endif);

helper def: sameBoundedContextNames(el1 : DDD!Element, el2 : DDD!Element) : Boolean =
	if(el1.goUpToElementWithStereotype('BoundedContext').name = el1.goUpToElementWithStereotype('BoundedContext').name)
		then
			true
		else
			false
	endif;
	
--helper context DDD!Package def: countDependenciesWithSupplier(object : DDD!Class) : Boolean =
--	thisModule.filterSequenceByType(self.packagedElement, DDD!Dependency) ->
--	iterate(iter; col: Sequence(DDD!Dependency) = Sequence{}|
--		if(iter.supplier.get(0).name = object.name and 
--			not (iter.supplier.get(0).goUpToElementWithStereotype('BoundedContext').name = iter.client.get(0).goUpToElementWithStereotype('BoundedContext').name)) --additionaly filter only dependencies with different bounded contexts
--			then
--				col.append(iter)
--		else
--			col
--		endif);
	
helper context DDD!Model def: collectAbstractionsWithClient(object : DDD!Class) : Boolean =
	self.getPackagedElementsByType(DDD!Abstraction) ->
	iterate(iter; col: Sequence(DDD!Abstraction) = Sequence{}|
		if(iter.client.get(0).name = object.name)
			then
				col.append(iter)
		else
			col
		endif);

helper context DDD!Package def: collectAbstractionsWithClientBC(object : DDD!Class) : Boolean =
	self.getPackagedElementsByType(DDD!Abstraction) ->
	iterate(iter; col: Sequence(DDD!Abstraction) = Sequence{}|
		if(iter.client.get(0).name = object.name)
			then
				col.append(iter)
		else
			col
		endif);

helper context DDD!Element def: collectAssociationsWithMemberEnd(object : DDD!Class) : Boolean =
	self.getPackagedElementsByType(DDD!Association) ->
	iterate(iter; col: Sequence(DDD!Association) = Sequence{}|
		if(iter.memberEnd.get(1).type.name = object.name)
			then
				col.append(iter)
		else
			col
		endif);

helper context DDD!Element def: goUpToElementWithStereotype (stereotype : String) : DDD!Element =
	if(self.hasStereotype(stereotype))
		then
			self
		else
			if(not self.namespace.oclIsUndefined())
				then
					self.namespace.goUpToElementWithStereotype(stereotype)
				else
					OclUndefined
				endif
		endif;

helper context DDD!Element def: goUpToElementWithType (type : OclType) : DDD!Element =
	if(self.oclIsTypeOf(type))
		then
			self
		else
			if(not self.namespace.oclIsUndefined())
				then
					self.namespace.goUpToElementWithType(type)
				else
					OclUndefined
				endif
		endif;

-- Goes recursively through all packages and collects the elements with specified type
helper context DDD!Element def: getPackagedElementsByType(type : String) : Sequence(DDD!Class) =
		self.packagedElement ->
			iterate(iter; col: Sequence(DDD!Element) = Sequence{}|
		if(iter.oclIsTypeOf(type))
			then
				col.append(iter)
		else
			if(iter.oclIsTypeOf(DDD!Package))
				then
				col.union(iter.getPackagedElementsByType(type))
			else
				col
			endif
		endif);

-- Goes recursively through all packages and collects the elements with specified type
helper context DDD!Element def: getPackagedElementsByStereoType(stereotype : String) : Sequence(DDD!Class) =
		self.packagedElement ->
			iterate(iter; col: Sequence(DDD!Element) = Sequence{}|
		if(iter.hasStereotype(stereotype))
			then
				col.append(iter)
		else
			if(iter.oclIsTypeOf(DDD!Package))
				then
				col.union(iter.getPackagedElementsByStereoType(stereotype))
			else
				col
			endif
		endif);

-- If no return type is given, take the subject from the owing elements associations, else 
helper context DDD!Operation def: getCorrectSubject() : DDD!Element =
	if(self.type.oclIsUndefined())
		then 
			-- return the end of the first association of the owning object
			if not self.namespace.getAllAssocationsFromProperties().first().oclIsUndefined()
				then
					self.namespace.getAllAssocationsFromProperties().first().memberEnd.first().type
				else
					self.namespace.goUpToElementWithType(DDD!Model).collectAssociationsWithMemberEnd(self.namespace).first().memberEnd.get(0).type
			endif
		else
			self.type
	endif;		

helper context DDD!Class def: suitableForInterface() : Boolean =
	if((self.hasStereotype('Repository') or self.hasStereotype('Service')))
		then
			if(self.countDependenciesOnThis().size() > 0)
				then
					true
				else
					-- =0 is to just have a false expression
					('[INFO] "Repository" or "Service" object with name "'+self.name+'" was not converted because there is no corresponding concept in AJIL').debug() = 0
				endif
		else 
			false
		endif;

--TODO: Delete this
helper def: getAbstractFromElement(element : DDD!Element) : DDD!Element =
	if(not element.goUpToElementWithStereotype('BoundedContext').oclIsUndefined())
		then
			element.goUpToElementWithStereotype('BoundedContext').collectAbstractionsWithClientBC(element).first()
		else
			OclUndefined
		endif;

helper def: getAbstractFromSharedModel(element : DDD!Element) : DDD!Element =
	if(element.goUpToElementWithStereotype('BoundedContext').oclIsUndefined())
		then
			element.goUpToElementWithType(DDD!Model).collectAbstractionsWithClient(element).first()
		else
			OclUndefined
		endif;

-- Helper to find out if both ends are transformed to other stuff, currently not working
helper context DDD!Association def: bothEndsTransformed() : Boolean =
	if(thisModule.resolveTemp(self.memberEnd.first().debug(),'new').debug().oclIsUndefined() or thisModule.resolveTemp(self.memberEnd.get(1).debug(), 'new').debug().oclIsUndefined())
		then
			false
		else
			true
		endif;

rule BoundedContext2MicroServiceAndDataModelWithoutAggregate {
	from
		p : DDD!Package (p.oclIsTypeOf(DDD!Package) and p.hasStereotype('BoundedContext') and p.getPackagedElementsByStereoType('AggregateRoot').size() = 0)
	to
		
		fs: AJI!FunctionalServiceT (
			name <- p.name + 'Service',
			domain <- dm,
			providedInterfaces <- p.getPackagedElementsByStereoType('Repository'),
			providedInterfaces <- p.getPackagedElementsByStereoType('Service'),
			serviceDependencies <- p.getDependenciesToOtherContexts()
		),
		
		dm:	AJI!DataModelT (
			name <- p.name + 'Model',
			entities <- p.getPackagedElementsByStereoType('Entity'),
			entities <- p.getPackagedElementsByStereoType('ValueObject'),
			entities <- p.getPackagedElementsByType(DDD!Enumeration)
		)
}

rule BoundedContext2MicroServiceAndDataModelWithAggregate {
	from
		p : DDD!Package (p.oclIsTypeOf(DDD!Package) and p.hasStereotype('BoundedContext') and p.getPackagedElementsByStereoType('AggregateRoot').size() > 0)
	to
		
		fs: AJI!FunctionalServiceT (
			name <- p.name + 'Service',
			domain <- dm,
			providedInterfaces <- p.getPackagedElementsByStereoType('Repository'),
			providedInterfaces <- p.getPackagedElementsByStereoType('Service'),
			serviceDependencies <- p.getDependenciesToOtherContexts()
		),
		
		aggRoot: AJI!EntityT(
			name <- 'AbstractAggregateRoot'
			),
			
		aggPart: AJI!EntityT(
			name <- 'AbstractAggregatePart'
			),
		
		dm:	AJI!DataModelT (
			name <- p.name + 'Model',
			entities <- p.getPackagedElementsByStereoType('Entity'),
			entities <- p.getPackagedElementsByStereoType('ValueObject'),
			entities <- p.getPackagedElementsByType(DDD!Enumeration),
			entities <- aggRoot,
			entities <- aggPart
		)
}

rule Module2Log{
	from
		old : DDD!Package (old.hasStereotype('Module'))
		
	to	

	do{
		('[INFO] "Module" object with name "'+old.name+ '" was not converted, because there is no corresponding concept in AJIL').println();
	}	
}

rule Model2System {
	
	from
		up : DDD!Model
	to		
		t: AJI!SystemT (
			name <- up.name,
			services <- up.nestedPackage
		)
}

rule Enum2Entity{
	from
		old : DDD!Enumeration
		
	to
		new : AJI!EntityT(
				name <- old.name,
				attributes <- old.ownedLiteral
			)
}

rule Entity2Entity_AggregateRoot{
	from
		old : DDD!Class ((old.hasStereotype('Entity') or old.generalizationHasStereotype('Entity')) and old.hasStereotype('AggregateRoot'))
		
	to
		new : AJI!EntityT(
				name <- old.name,
				attributes <- old.attribute,
				relations <- old.getAllAssocationsFromProperties(),
				parent <- thisModule.resolveTemp(old.goUpToElementWithStereotype('BoundedContext'), 'aggRoot'),
				parent <- old.getGeneralization(),
				domainModel <- thisModule.resolveTemp(old.generalizationBoundedContext(), 'dm')
			)
}


rule Entity2Entity_NoAggregate{
	from
		old : DDD!Class ((old.hasStereotype('Entity') or old.generalizationHasStereotype('Entity')) 
			and not (old.hasStereotype('AggregateRoot') or old.hasStereotype('AggregatePart')))
	to
		new : AJI!EntityT(
				name <- old.name,
				attributes <- old.attribute,
				relations <- old.getAllAssocationsFromProperties(),
				parent <- old.getGeneralization(),
				domainModel <- thisModule.resolveTemp(old.generalizationBoundedContext(), 'dm')
			)
}

rule Entity2Entity_AggregatePart{
	from
		old : DDD!Class ((old.hasStereotype('Entity') or old.generalizationHasStereotype('Entity')) and old.hasStereotype('AggregatePart'))
		
	to
		new : AJI!EntityT(
				name <- old.name,
				relations <- rel,
				relations <- old.getAllAssocationsFromProperties(),
				attributes <- old.attribute,
				parent <- thisModule.resolveTemp(old.goUpToElementWithStereotype('BoundedContext'), 'aggPart'),
				parent <- old.getGeneralization(),
				domainModel <- thisModule.resolveTemp(old.generalizationBoundedContext(), 'dm')
			),
			
			rel : AJI!RelationT(
				name <- 'AggregateRoot',
				target <- old.getAggregateRoot()
			)
}

rule ValueObject2Entity{
	from
		old : DDD!Class (old.hasStereotype('ValueObject') and not old.goUpToElementWithStereotype('BoundedContext').oclIsUndefined())
		
	to
		new : AJI!EntityT(
				name <- old.name,
				attributes <- old.attribute
			)
}

rule SharedModel2Entity{
	from
		old : DDD!Class (old.hasStereotype('ValueObject') and old.goUpToElementWithStereotype('BoundedContext').oclIsUndefined())
	using{
		abstraction : DDD!Abstraction = thisModule.getAbstractFromSharedModel(old).supplier.get(0);
	}	
	to
		new : AJI!EntityT(
				name <- old.name,
				attributes <- old.attribute,
				domainModel <- thisModule.resolveTemp(abstraction.goUpToElementWithStereotype('BoundedContext'), 'dm'),
				parent <- abstraction
			)
}

rule Property2Attribute_Integer{
	from
		old : DDD!Property (old.isPrimitiveType('Integer')) 
	to	
			new : AJI!IntegerT(
				name <- old.name
			)
}

rule Property2Attribute_String{
	from
		old : DDD!Property (old.isPrimitiveType('String')) 
	to	
			new : AJI!StringT(
				name <- old.name
			)
}

rule Property2Attribute_Float{
	from
		old : DDD!Property (old.isPrimitiveType('Float')) 
	to	
			new : AJI!FloatT(
				name <- old.name
			)
}

rule Property2Attribute_Boolean{
	from
		old : DDD!Property (old.isPrimitiveType('Boolean')) 
	to	
			new : AJI!BooleanT(
				name <- old.name
			)
}

rule Property2Attribute_Undefined{
	from
		old : DDD!Property (old.type.oclIsUndefined()  and not(old.name = 'AggregateRoot'))
		
	to	
			new : AJI!StringT(
				name <- old.name
			)
}

rule EnumerationLiteral2Attribute{
	from
		old : DDD!EnumerationLiteral		
	to	
			new : AJI!StringT(
				name <- old.name
			)
}

rule Property2Attribute_Association{
	from
		old : DDD!Property (not old.association.oclIsUndefined() and (old.namespace.hasStereotype('Entity') or old.namespace.hasStereotype('ValueObject'))) --and not old.isPropertyOfAssociation())
		
	to	
			new : AJI!EntityT(
				name <- old.name
			)
}

rule RepositoryOrService2ServiceInterface{
	from
		old : DDD!Class (old.suitableForInterface())
	to
		new : AJI!ServiceInterfaceT(
				name <- old.name + 'Interface',
				abilities <- old.ownedOperation
			)
}

--Checking the type with the first characters, because a regex search can be ambigoous with createReader or something
rule Operation2CreateAbility{
	from
		old: DDD!Operation ((old.namespace.hasStereotype('Repository') or old.namespace.hasStereotype('Service')) and
			old.name.substring(1,6) = 'create' and old.namespace.countDependenciesOnThis().size() > 0)
	to
		new : AJI!CreateT( 
				name <- old.name,
				--No way to distinguish between multiple associations on a repo or service
				subject <- old.getCorrectSubject()
			)
}

rule Operation2ReadAbility{
	from
		old: DDD!Operation ((old.namespace.hasStereotype('Repository') or old.namespace.hasStereotype('Service')) and
			(old.name.substring(1,4) = 'find' or old.name.substring(1,4) = 'read' or old.name.substring(1,3) = 'get')
			and old.namespace.countDependenciesOnThis().size() > 0)
	to
		new : AJI!ReadT( 
				name <- old.name,
				--No way to distinguish between multiple associations on a repo or service
				subject <- old.getCorrectSubject()
			)
}

rule Operation2UpdateAbility{
	from
		old: DDD!Operation ((old.namespace.hasStereotype('Repository') or old.namespace.hasStereotype('Service')) and
			old.name.substring(1,6) = 'update' and old.namespace.countDependenciesOnThis().size() > 0)
	to
		new : AJI!UpdateT( 
				name <- old.name,
				--No way to distinguish between multiple associations on a repo or service
				subject <- old.getCorrectSubject()
			)
}

rule Operation2DeleteAbility{
	from
		old: DDD!Operation ((old.namespace.hasStereotype('Repository') or old.namespace.hasStereotype('Service')) and
			(old.name.substring(1,6) = 'delete' or old.name.substring(1,6) = 'remove')
			and old.namespace.countDependenciesOnThis().size() > 0)
	to
		new : AJI!DeleteT( 
				name <- old.name,
				--No way to distinguish between multiple associations on a repo or service
				subject <- old.getCorrectSubject()
			)
}

rule Operation2CustomAbility{
	from
		old: DDD!Operation (old.namespace.hasStereotype('Service') and not
			(old.name.substring(1,6) = 'create' or
				old.name.substring(1,4) = 'find' or old.name.substring(1,4) = 'read' or old.name.substring(1,3) = 'get' or
				old.name.substring(1,6) = 'update'or
				old.name.substring(1,6) = 'delete' or old.name.substring(1,6) = 'remove')	
			and old.namespace.countDependenciesOnThis().size() > 0
		)
	to
		new : AJI!CustomT( 
				name <- old.name,
				--No way to distinguish between multiple associations on a repo or service
				subject <- old.getCorrectSubject()
			)
}


rule EntityAssociations{
	from
		old : DDD!Association (old.associationOriginHasStereotype('Entity') and not old.isManyToManyAssociation() 
			and not old.isManyToOneAssociation())
		
	to	
			new : AJI!RelationT(
				target <- old.memberEnd.first().type,
				source <- old.memberEnd.get(1).type,
				multiplicity <-  if (old.memberEnd.first().upper = -1) then 'MANY' else 'ONE' endif
				--name <- old.memberEnd.get(1).name + '->' + old.memberEnd.first().name
			)
}

rule splitManyToManyEntityAssociations{
	from
		old : DDD!Association (old.associationOriginHasStereotype('Entity') and old.isManyToManyAssociation())
		-- Checken ob Assoziationen zwischen Bounded Contexts sind
	to	
			new : AJI!RelationT(
				target <- old.memberEnd.first().type,
				source <- old.memberEnd.get(1).type,
				multiplicity <- 'MANY'
				--name <- '1: ' + old.memberEnd.get(1).name + '->' + old.memberEnd.first().name
			),
			
			new2 : AJI!RelationT(
				target <- old.memberEnd.get(1).type,
				source <- old.memberEnd.first().type,
				multiplicity <- 'MANY'
				--name <- '2: ' + old.memberEnd.first().name + '->' + old.memberEnd.get(1).name
			)
}

rule Spec2Log{
	from
		old : DDD!Class (old.hasStereotype('Spec'))
		
	to	

	do{
		('[INFO] "Spec" object with name "'+old.name+ '" was not converted, because there is no corresponding concept in AJIL').println();
	}	
}


